"""
Audio API Module for MOSAIC

This module provides API endpoints for serving audio files generated by the podcaster agent.
"""

import logging
import os
from typing import Optional
from fastapi import APIRouter, HTTPException, status
from fastapi.responses import FileResponse, JSONResponse
from pathlib import Path
from datetime import datetime

# Configure logging
logger = logging.getLogger("mosaic.backend.app.audio_api")

# Create router
router = APIRouter(prefix="/api/audio", tags=["audio"])

# Get the audio output directory
try:
    # Get backend directory (parent of app directory)
    BACKEND_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    AUDIO_DIR = os.path.join(BACKEND_DIR, "audio_output")
    os.makedirs(AUDIO_DIR, exist_ok=True)  # Ensure directory exists
    logger.info(f"Audio directory configured: {AUDIO_DIR}")
except Exception as e:
    logger.error(f"Error setting up audio directory: {str(e)}")
    raise

# List endpoint must come before {filename} to be matched correctly
@router.get("/list")
async def list_audio_files():
    """
    List all audio files in the audio output directory.
    
    Returns:
        JSON array containing information about all audio files
    """
    try:
        files = []
        for file in os.scandir(AUDIO_DIR):
            if file.is_file() and file.name.lower().endswith(('.mp3', '.opus', '.aac', '.flac', '.wav', '.pcm')):
                stat = file.stat()
                files.append({
                    "name": file.name,
                    "size": stat.st_size,
                    "created": datetime.fromtimestamp(stat.st_ctime).isoformat(),
                    "modified": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                    "format": file.name.split('.')[-1].lower(),
                    "url": f"/api/audio/{file.name}"
                })
        
        # Sort by creation time, newest first
        files.sort(key=lambda x: x["created"], reverse=True)
        return JSONResponse(content=files)
    except Exception as e:
        logger.error(f"Error listing audio files: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to list audio files"
        )

@router.get("/{filename}")
async def get_audio_file(filename: str):
    """
    Serve an audio file from the audio output directory.
    
    Args:
        filename: The name of the audio file to serve
        
    Returns:
        The audio file as a streaming response
    """
    # Construct the file path
    file_path = os.path.join(AUDIO_DIR, filename)
    
    # Verify the file exists and is within the audio directory
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="Audio file not found")
    
    if not os.path.abspath(file_path).startswith(AUDIO_DIR):
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Get the file's mime type based on extension
    mime_type = {
        'mp3': 'audio/mpeg',
        'opus': 'audio/opus',
        'aac': 'audio/aac',
        'flac': 'audio/flac',
        'wav': 'audio/wav',
        'pcm': 'audio/l16'  # Linear PCM
    }.get(file_path.split('.')[-1].lower(), 'application/octet-stream')
    
    # Return the file with proper content type and allow caching
    return FileResponse(
        file_path,
        media_type=mime_type,
        filename=filename,
        headers={
            "Cache-Control": "public, max-age=31536000",
            "Access-Control-Allow-Origin": "*"
        }
    )

@router.delete("/{filename}")
async def delete_audio_file(filename: str):
    """
    Delete an audio file from the audio output directory.
    
    Args:
        filename: The name of the audio file to delete
        
    Returns:
        Success message
    """
    # Construct the file path
    file_path = os.path.join(AUDIO_DIR, filename)
    
    # Verify the file exists and is within the audio directory
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="Audio file not found")
    
    if not os.path.abspath(file_path).startswith(AUDIO_DIR):
        raise HTTPException(status_code=403, detail="Access denied")
    
    try:
        os.remove(file_path)
        return {"message": f"Successfully deleted {filename}"}
    except Exception as e:
        logger.error(f"Error deleting audio file {filename}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to delete {filename}"
        )

@router.get("/{filename}/info")
async def get_audio_info(filename: str):
    """
    Get information about an audio file.
    
    Args:
        filename: The name of the audio file
        
    Returns:
        JSON object containing file information
    """
    # Construct the file path
    file_path = os.path.join(AUDIO_DIR, filename)
    
    # Verify the file exists
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="Audio file not found")
    
    # Get file information
    file_stat = os.stat(file_path)
    
    return {
        "name": filename,
        "size": file_stat.st_size,
        "created": file_stat.st_ctime,
        "modified": file_stat.st_mtime,
        "format": filename.split('.')[-1].lower()
    }
